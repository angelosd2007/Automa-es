#Baixa e analisa demandas pendentes do BACEN
#Deixar sempre a pasta downloand limpa - sem arquivos
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from pykeepass import PyKeePass
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from datetime import datetime, timedelta
import getpass
import os
import time
import pandas as pd
import matplotlib.pyplot as plt

# Configura√ß√µes do caminho
download_dir = r'C:\Users\u003985\Downloads'  # Altere conforme seu diret√≥rio de downloads

# Configura√ß√£o do Slack
slack_token = ''
canal_slack = ''

client = WebClient(token=slack_token)

# Fun√ß√£o para esperar o download completar
def wait_for_download(directory, timeout=60):
    seconds = 0
    downloaded = False
    file_name = None
    while not downloaded and seconds < timeout:
        time.sleep(1)
        files_after_download = [f for f in os.listdir(directory) if not f.endswith('.crdownload')]
        if files_after_download:
            file_name = files_after_download[0]  # Sup√µe-se o primeiro/√∫nico arquivo baixado
        downloaded = bool(file_name)
        seconds += 1
    return file_name if downloaded else None

# Acessando usu√°rio e senha KeePass
frase_segura = getpass.getpass("Digite sua senha KeePass: ")
kp = PyKeePass(r'C:\Users\u003985\Documents\Consulta SCR\senhas.kdbx', password=frase_segura)

# Pergunta qual empresa acessar
empresa = input("Qual empresa deseja acessar? (1 para financeira, 2 para pagamentos): ")

# Configura√ß√µes do navegador
chrome_options = Options()
chrome_options.add_experimental_option("prefs", {
    "download.default_directory": download_dir,
    "download.prompt_for_download": False,  # Baixa automaticamente sem pedir para salvar
    "download.directory_upgrade": True
})

#Acessando o site com webdrivre
driver = webdriver.Chrome(options=chrome_options)
driver.get("https://www3.bcb.gov.br/rdr/consultaDemandaIFDatasConglomerado.do?method=consultarDemandasPendentesConglomerado")

#Fun√ß√£o para esperar o site carregar
WebDriverWait(driver, 10).until(lambda d: d.execute_script("return document.readyState") == "complete")

# Encontra as credenciais
if empresa == '1':
    entry = kp.find_entries(title='Neon Financeira Bacen', first=True)
else:
    entry = kp.find_entries(title='Nome_da_Entrada_Pagamentos', first=True)

if entry is None:
    print("Entrada n√£o encontrada no KeePass.")
    driver.quit()
    exit()

username = entry.username
password = entry.password

# Insere o usu√°rio e senha
driver.find_element(By.XPATH, '//*[@id="userNameInput"]').send_keys(username)
driver.find_element(By.XPATH, '//*[@id="passwordInput"]').send_keys(password)

# Clica no bot√£o de login
driver.find_element(By.XPATH, '//*[@id="submitButton"]').click()

# Clique nos pr√≥ximos elementos conforme solicitado
driver.find_element(By.XPATH, '//*[@id="oCMenu_MenuConglomerado"]').click()
driver.find_element(By.XPATH, '//*[@id="oCMenu_ConsultarDemandasPendentes"]').click()

# Clica no bot√£o ordenar
driver.find_element(By.XPATH, '//*[@id="ordenado"]').click()

# Clica no bot√£o final
driver.find_element(By.XPATH, '//*[@id="pesquisaIFForm"]/input[4]').click()

# Clica no bot√£o de download
driver.find_element(By.XPATH, '/html/body/div[10]/div/a[1]').click()

# Esperar at√© que o download seja conclu√≠do e renomear
downloaded_file = wait_for_download(download_dir)
if downloaded_file:
    print("Download completo!")
    old_file_path = os.path.join(download_dir, downloaded_file)
    new_file_path = os.path.join(download_dir, "Demandas_Pendentes" + os.path.splitext(downloaded_file)[1])
    os.rename(old_file_path, new_file_path)
    print(f"Arquivo renomeado para {new_file_path}")
else:
    print("O download n√£o foi completado no tempo esperado.")
    driver.quit()
    exit()

# Fecha o navegador ap√≥s download
driver.quit()

# An√°lise com Pandas e Matplotlib
# Passo 1: Carregar a planilha e especificar a linha de cabe√ßalho correta
df = pd.read_excel(new_file_path, header=2)  # A linha 3 em √≠ndice 0-based equivale a header=2

# Exiba as colunas carregadas para verifica√ß√£o
print("Colunas carregadas:", df.columns)

# Passo 2: Filtrar as colunas de interesse
df = df[['N√∫mero', 'Disponibiliza√ß√£o', 'Prazo', 'Institui√ß√£o']]
df.columns = ['Protocolo', 'Data Entrada', 'Prazo Resposta', 'Institui√ß√£o']

# Renomear 'Institui√ß√£o' na coluna
df['Institui√ß√£o'] = df['Institui√ß√£o'].str.strip().replace({
    'NEON PAGAMENTOS S.A. - INSTITUI√á√ÉO DE PAGAMENTO': 'NEON PAGAMENTOS',
    'NEON FINANCEIRA - CR√âDITO, FINANCIAMENTO E INVESTIMENTO S.A.': 'NEON FINANCEIRA'
})

# Converte as colunas de data para o formato datetime
df['Data Entrada'] = pd.to_datetime(df['Data Entrada'], errors='coerce').dt.date  # Extraindo apenas a data
df['Prazo Resposta'] = pd.to_datetime(df['Prazo Resposta'], errors='coerce').dt.date  # Extraindo apenas a data

# Passo 3: An√°lise - Demandas com prazo pr√≥ximo e demandas do dia atual
hoje = datetime.today().date()
demandas_total = df["Protocolo"].count()
demandas_dia = df[df['Data Entrada'] == hoje]
demandas_prazo_proximo = df[df['Prazo Resposta'] == hoje]
demandas_prazo_d9 = df[df['Prazo Resposta'] == hoje + timedelta(days=1)]
demandas_prazo_d8 = df[df['Prazo Resposta'] == hoje + timedelta(days=2)]

# Exibe as demandas do dia atual
print(f"Demandas com data de entrada no dia de hoje ({hoje}):")
print(demandas_dia)
print(f"Soma de demandas do dia: {len(demandas_dia)}")

# Exibe as demandas com prazos pr√≥ximos
print("Demandas com prazo de resposta at√© hoje:")
print(demandas_prazo_proximo)
print(f"Soma de demandas com prazo at√© hoje: {len(demandas_prazo_proximo)}")

# Agrupando demandas e contando total por "Prazo Resposta" e "Institui√ß√£o"
demandas_total_agrupado = df.groupby(["Prazo Resposta", "Institui√ß√£o"])["Protocolo"].count().reset_index()

# Gerar mensagem resumo_analise
resumo_analise = f"""

üèõ ùóñùóºùóªùó≥ùó≤ùóøùó≤ÃÇùóªùó∞ùó∂ùóÆ ùóïùóÆùó∞ùó≤ùóª - {hoje.strftime('%d/%m/%Y')} üèõ

Seguem dados de demandas para confer√™ncia:

Ôºä ùóßùóºùòÅùóÆùóπ ùó±ùó≤ ùó±ùó≤ùó∫ùóÆùóªùó±ùóÆùòÄ ùóÆùóØùó≤ùóøùòÅùóÆùòÄ ùó∞ùóºùó∫ ùóΩùóøùóÆùòáùóº ùóõùóºùó∑ùó≤: {len(demandas_prazo_proximo)} 
{"Demandas com prazo em D10 foram integralmente fechadas ‚úî" if len(demandas_prazo_proximo) == 0 else "H√° demandas pendentes com prazo hoje‚ùó"}

Ôºä Total de demandas que entraram hoje: {len(demandas_dia)}

Pr√≥ximos Prazos:
"""

# Inicializando a vari√°vel 'mensagem'
mensagem = ""

# Iterar sobre grupos de demanda pelo "Prazo Resposta"
for prazo, group in demandas_total_agrupado.groupby("Prazo Resposta"):
    # Contar o total de demandas para o prazo
    total_demandas = group["Protocolo"].sum()  # Total de protocolos para cada prazo

    # Contar demandas por canal (institui√ß√£o) usando count()
    demanda_por_canal = group.groupby("Institui√ß√£o")["Protocolo"].sum()

    # Adicionar cabe√ßalho para a data atual
    mensagem += f"{prazo.strftime('%d/%m/%Y')} - Total demandas ({total_demandas}):\n"

    # Adicionar dados dos canais com gr√°ficos de barras
    for canal, quantidade in demanda_por_canal.items():
        barras = "‚ñà" * quantidade  # Cada barra representa uma unidade
        mensagem += f"  {canal:<15}: {barras} ({quantidade})\n"

    mensagem += "\n"  # Linha em branco entre datas

# Adicionar mensagem final
mensagem += f"Total de demandas em aberto com prazos futuros: {demandas_total}\n\n"
mensagem += "Confer√™ncia finalizada ‚úî\n\n" if len(demandas_prazo_proximo) == 0 else "Verifique as demandas pendentes com vencimento hoje‚ùó\n\n"
mensagem += f"ùó¢ùòÇùòÉùó∂ùó±ùóºùóøùó∂ùóÆ ùó°ùó≤ùóºùóª\nùó¶ùóÆÃÉùóº ùó£ùóÆùòÇùóπùóº, {hoje.strftime('%d/%m/%Y')}\n"

# Combinar mensagens
resumo_analise += mensagem

# Passo 5: Gerar gr√°ficos

# Gr√°fico 1: Soma de demandas por data de entrada
demandas_por_data_entrada = df.groupby('Data Entrada').size()

plt.figure(figsize=(10, 6))
plt.bar(demandas_por_data_entrada.index.map(lambda x: x.strftime('%d/%m/%Y')), demandas_por_data_entrada.values)
plt.title('Soma de Demandas por Data de Entrada')
plt.xlabel('Data de Entrada')
plt.ylabel('Total de Demandas')
plt.xticks(rotation=45)
plt.tight_layout()

# Adicionar r√≥tulos de dados
for i, v in enumerate(demandas_por_data_entrada):
    plt.text(i, v + 0.5, str(v), ha='center', va='bottom')

plt.show(block=False)
plt.pause(3)
plt.close()

# Gr√°fico 2: Demandas futuras ordenadas por prazo de resposta
demandas_futuras = df[df['Prazo Resposta'] >= hoje]
demandas_futuras_ordenadas = demandas_futuras.groupby('Prazo Resposta').size()

plt.figure(figsize=(10, 6))
plt.bar(demandas_futuras_ordenadas.index.map(lambda x: x.strftime('%d/%m/%Y')), demandas_futuras_ordenadas.values)
plt.title('Demandas Futuras Ordenadas por Prazo de Resposta')
plt.xlabel('Prazo de Resposta')
plt.ylabel('N√∫mero de Demandas')
plt.xticks(rotation=45)
plt.tight_layout()

# Adicionar r√≥tulos de dados
for i, v in enumerate(demandas_futuras_ordenadas):
    plt.text(i, v + 0.5, str(v), ha='center', va='bottom')

plt.show(block=False)
plt.pause(3)
plt.close()

# Passo 6: Descri√ß√£o da an√°lise
print("\nResumo da an√°lise:")
print(f"Total de demandas do dia atual ({hoje}): {len(demandas_dia)}")
print(f"Total de demandas com prazo de resposta at√© hoje: {len(demandas_prazo_proximo)}")

print(resumo_analise)

# Fun√ß√£o para enviar mensagem ao Slack
def enviar_para_slack(mensagem, canal):
    try:
        response = client.chat_postMessage(channel=canal, text=mensagem)
        print(f"Mensagem enviada para o Slack: {response['ts']}")
    except SlackApiError as e:
        print(f"Erro ao enviar mensagem para o Slack: {e.response['error']}")

# Pedido de confirma√ß√£o para o usu√°rio
confirmacao = input("\nDeseja enviar a confer√™ncia para o Slack? (s/n): ").strip().lower()

if confirmacao == 's':
    # Enviar resumo para o Slack
    enviar_para_slack(resumo_analise, canal_slack)
else:
    print("Envio ao Slack cancelado.")
