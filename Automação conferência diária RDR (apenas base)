# AnÃ¡lise de demandas pendentes do BACEN, assumindo que o arquivo jÃ¡ estÃ¡ baixado manualmente
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from pykeepass import PyKeePass
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import os

# ConfiguraÃ§Ãµes do caminho
download_dir = r'C:\Users\u003985\Downloads'  # Altere conforme seu diretÃ³rio de downloads
arquivo_downloaded = "demandas.xlsx"  # Nome do arquivo que vocÃª baixou manualmente

# ConfiguraÃ§Ã£o do Slack
slack_token = ''
canal_slack = ''

client = WebClient(token=slack_token)

# Passo 1: Carregar a planilha e especificar a linha de cabeÃ§alho correta
file_path = os.path.join(download_dir, arquivo_downloaded)  # Caminho do arquivo
df = pd.read_excel(file_path, header=2)  # A linha 3 em Ã­ndice 0-based equivale a header=2

# Exiba as colunas carregadas para verificaÃ§Ã£o
print("Colunas carregadas:", df.columns)

# Passo 2: Filtrar as colunas de interesse
df = df[['NÃºmero', 'DisponibilizaÃ§Ã£o', 'Prazo', 'InstituiÃ§Ã£o']]
df.columns = ['Protocolo', 'Data Entrada', 'Prazo Resposta', 'InstituiÃ§Ã£o']

# Renomear 'InstituiÃ§Ã£o' na coluna
df['InstituiÃ§Ã£o'] = df['InstituiÃ§Ã£o'].str.strip().replace({
    'NEON PAGAMENTOS S.A. - INSTITUIÃ‡ÃƒO DE PAGAMENTO': 'NEON PAGAMENTOS',
    'NEON FINANCEIRA - CRÃ‰DITO, FINANCIAMENTO E INVESTIMENTO S.A.': 'NEON FINANCEIRA'
})

# Converte as colunas de data para o formato datetime
df['Data Entrada'] = pd.to_datetime(df['Data Entrada'], errors='coerce').dt.date  # Extraindo apenas a data
df['Prazo Resposta'] = pd.to_datetime(df['Prazo Resposta'], errors='coerce').dt.date  # Extraindo apenas a data

# Passo 3: AnÃ¡lise - Demandas com prazo prÃ³ximo e demandas do dia atual
hoje = datetime.today().date()
demandas_total = df["Protocolo"].count()
demandas_dia = df[df['Data Entrada'] == hoje]
demandas_prazo_proximo = df[df['Prazo Resposta'] == hoje]
demandas_prazo_d9 = df[df['Prazo Resposta'] == hoje + timedelta(days=1)]
demandas_prazo_d8 = df[df['Prazo Resposta'] == hoje + timedelta(days=2)]

# Exibe as demandas do dia atual
print(f"Demandas com data de entrada no dia de hoje ({hoje}):")
print(demandas_dia)
print(f"Soma de demandas do dia: {len(demandas_dia)}")

# Exibe as demandas com prazos prÃ³ximos
print("Demandas com prazo de resposta atÃ© hoje:")
print(demandas_prazo_proximo)
print(f"Soma de demandas com prazo atÃ© hoje: {len(demandas_prazo_proximo)}")

# Agrupando demandas e contando total por "Prazo Resposta" e "InstituiÃ§Ã£o"
demandas_total_agrupado = df.groupby(["Prazo Resposta", "InstituiÃ§Ã£o"])["Protocolo"].count().reset_index()

# Gerar mensagem resumo_analise
resumo_analise = f"""
ğŸ› ğ—–ğ—¼ğ—»ğ—³ğ—²ğ—¿ğ—²Ì‚ğ—»ğ—°ğ—¶ğ—® ğ—•ğ—®ğ—°ğ—²ğ—» - {hoje.strftime('%d/%m/%Y')} ğŸ›
Seguem dados de demandas para conferÃªncia:
ï¼Š ğ—§ğ—¼ğ˜ğ—®ğ—¹ ğ—±ğ—² ğ—±ğ—²ğ—ºğ—®ğ—»ğ—±ğ—®ğ˜€ ğ—®ğ—¯ğ—²ğ—¿ğ˜ğ—®ğ˜€ ğ—°ğ—¼ğ—º ğ—½ğ—¿ğ—®ğ˜‡ğ—¼ ğ—›ğ—¼ğ—·ğ—²: {len(demandas_prazo_proximo)} 
{"Demandas com prazo em D10 foram integralmente fechadas âœ”" if len(demandas_prazo_proximo) == 0 else "HÃ¡ demandas pendentes com prazo hojeâ—"}
ï¼Š Total de demandas que entraram hoje: {len(demandas_dia)}
PrÃ³ximos Prazos:
"""

# Inicializando a variÃ¡vel 'mensagem'
mensagem = ""

# Iterar sobre grupos de demanda pelo "Prazo Resposta"
for prazo, group in demandas_total_agrupado.groupby("Prazo Resposta"):
    total_demandas = group["Protocolo"].sum()  # Total de protocolos para cada prazo
    demanda_por_canal = group.groupby("InstituiÃ§Ã£o")["Protocolo"].sum()
    
    mensagem += f"{prazo.strftime('%d/%m/%Y')} - Total demandas ({total_demandas}):\n"
    
    for canal, quantidade in demanda_por_canal.items():
        barras = "â–ˆ" * quantidade  # Cada barra representa uma unidade
        mensagem += f"  {canal:<15}: {barras} ({quantidade})\n"
    
    mensagem += "\n"  # Linha em branco entre datas

# Adicionar mensagem final
mensagem += f"Total de demandas em aberto com prazos futuros: {demandas_total}\n\n"
mensagem += "ConferÃªncia finalizada âœ”\n\n" if len(demandas_prazo_proximo) == 0 else "Verifique as demandas pendentes com vencimento hojeâ—\n\n"
mensagem += f"ğ—¢ğ˜‚ğ˜ƒğ—¶ğ—±ğ—¼ğ—¿ğ—¶ğ—® ğ—¡ğ—²ğ—¼ğ—»\nğ—¦ğ—®Ìƒğ—¼ ğ—£ğ—®ğ˜‚ğ—¹ğ—¼, {hoje.strftime('%d/%m/%Y')}\n"

# Combinar mensagens
resumo_analise += mensagem

# Passo 5: Gerar grÃ¡ficos
# GrÃ¡fico 1: Soma de demandas por data de entrada
demandas_por_data_entrada = df.groupby('Data Entrada').size()
plt.figure(figsize=(10, 6))
plt.bar(demandas_por_data_entrada.index.map(lambda x: x.strftime('%d/%m/%Y')), demandas_por_data_entrada.values)
plt.title('Soma de Demandas por Data de Entrada')
plt.xlabel('Data de Entrada')
plt.ylabel('Total de Demandas')
plt.xticks(rotation=45)
plt.tight_layout()

# Adicionar rÃ³tulos de dados
for i, v in enumerate(demandas_por_data_entrada):
    plt.text(i, v + 0.5, str(v), ha='center', va='bottom')

plt.show(block=False)
plt.pause(3)
plt.close()

# GrÃ¡fico 2: Demandas futuras ordenadas por prazo de resposta
demandas_futuras = df[df['Prazo Resposta'] >= hoje]
demandas_futuras_ordenadas = demandas_futuras.groupby('Prazo Resposta').size()
plt.figure(figsize=(10, 6))
plt.bar(demandas_futuras_ordenadas.index.map(lambda x: x.strftime('%d/%m/%Y')), demandas_futuras_ordenadas.values)
plt.title('Demandas Futuras Ordenadas por Prazo de Resposta')
plt.xlabel('Prazo de Resposta')
plt.ylabel('NÃºmero de Demandas')
plt.xticks(rotation=45)
plt.tight_layout()

# Adicionar rÃ³tulos de dados
for i, v in enumerate(demandas_futuras_ordenadas):
    plt.text(i, v + 0.5, str(v), ha='center', va='bottom')

plt.show(block=False)
plt.pause(3)
plt.close()

# Passo 6: DescriÃ§Ã£o da anÃ¡lise
print("\nResumo da anÃ¡lise:")
print(f"Total de demandas do dia atual ({hoje}): {len(demandas_dia)}")
print(f"Total de demandas com prazo de resposta atÃ© hoje: {len(demandas_prazo_proximo)}")
print(resumo_analise)

# FunÃ§Ã£o para enviar mensagem ao Slack
def enviar_para_slack(mensagem, canal):
    try:
        response = client.chat_postMessage(channel=canal, text=mensagem)
        print(f"Mensagem enviada para o Slack: {response['ts']}")
    except SlackApiError as e:
        print(f"Erro ao enviar mensagem para o Slack: {e.response['error']}")

# Pedido de confirmaÃ§Ã£o para o usuÃ¡rio
confirmacao = input("\nDeseja enviar a conferÃªncia para o Slack? (s/n): ").strip().lower()
if confirmacao == 's':
    # Enviar resumo para o Slack
    enviar_para_slack(resumo_analise, canal_slack)
else:
    print("Envio ao Slack cancelado.")
