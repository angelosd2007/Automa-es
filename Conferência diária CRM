from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from datetime import datetime, timedelta
import requests
import os
import pandas as pd
import matplotlib.pyplot as plt

# Configura√ß√µes do caminho
download_dir = r'c:\Users\u003985\Downloads' # Altere conforme seu diret√≥rio de downloads

# Configura√ß√£o do Slack
slack_token = ''
canal_slack = ''

#Ativando WebClients
client = WebClient(token=slack_token)

# An√°lise com Pandas e Matplotlib
# Carregar a planilha
file_path = r'c:\Users\u003985\Downloads\Lista de Demandas - Todas (Todas).xlsx'
df = pd.read_excel(file_path, header=3, engine='openpyxl')

# Passo 2: Filtrar as colunas de interesse e renomear
df = df[['Status', 'Canal Entrada', 'Identificador', 'Recebida', 'Prazo']]

# Filtrar os dados pela coluna 'Status'
status_interessados = ['Pendente', 'Aberto', 'Reaberto', 'Classificar']
df = df[df['Status'].isin(status_interessados)]

# Convers√£o das colunas 'Prazo' e 'Recebida' para datetime
colunas_datas = ['Prazo', 'Recebida']

for coluna in colunas_datas:
    df[coluna] = pd.to_datetime(df[coluna], format='%d-%m-%Y %H:%M', errors='coerce')  # Extraindo apenas a data

# Agora, extraindo somente a data (sem hora)
for coluna in colunas_datas:
    df[coluna] = df[coluna].dt.date  # Apenas a parte da data, retirando ou ignorando a hora

# An√°lise - Demandas do dia atual e prazos pr√≥ximos
hoje = datetime.today().date()
demandas = df['Prazo']
demandas_total = df["Identificador"].count()
demandas_dia = df[df['Recebida'] == hoje]
demandas_prazo_proximo = df[df['Prazo'] == hoje]

# Exibe as demandas do dia atual
print(f"Demandas com data de entrada no dia de hoje ({hoje}):")
print(demandas_dia)
print(f"Soma de demandas do dia: {len(demandas_dia)}")  # Soma de protocolos

# Exibe as demandas com prazos pr√≥ximos
print("Demandas com prazo de resposta at√© hoje:")
print(demandas_prazo_proximo)
print(f"Soma de demandas com prazo at√© hoje: {len(demandas_prazo_proximo)}")

# Criar a tabela din√¢mica
tabela_pivot = pd.pivot_table(df, values='Identificador', index='Canal Entrada', 
                               columns='Prazo', aggfunc='count', fill_value=0, 
                               margins=True, margins_name='Total')

# Gerar mensagem resumo_analise
resumo_analise = f"""

üõ° ùóñùóºùóªùó≥ùó≤ùóøùó≤ÃÇùóªùó∞ùó∂ùóÆ ùóóùó∂ùóÆÃÅùóøùó∂ùóÆ ùó±ùó≤ {hoje.strftime('%d/%m/%Y')} üõ°

Em acompanhamento ao nosso controle di√°rio, seguem dados de demandas para confer√™ncia:

Ôºä ùóßùóºùòÅùóÆùóπ ùó±ùó≤ ùó±ùó≤ùó∫ùóÆùóªùó±ùóÆùòÄ ùóÆùóØùó≤ùóøùòÅùóÆùòÄ ùó∞ùóºùó∫ ùóΩùóøùóÆùòáùóº ùóõùóºùó∑ùó≤: {len(demandas_prazo_proximo)} 
{"Demandas com prazo em D10 foram integralmente fechadas ‚úî" if len(demandas_prazo_proximo) == 0 else "‚õîVerifique as demandas pendentes‚ùó"}

Pr√≥ximos Prazos:
"""

# Inicializando a vari√°vel 'mensagem'
mensagem = ""

# Filtrar DataFrame para incluir apenas prazos futuros ou hoje
df_futuras = df[df["Prazo"] >= hoje]

for prazo, group in df_futuras.groupby("Prazo"):
    # Contar o total de demandas para o prazo
    total_demandas = group.shape[0]

    # Contar demandas por canal
    demanda_por_canal = group.groupby("Canal Entrada")["Identificador"].count()

    # Adicionar cabe√ßalho para a data atual
    mensagem += f"{prazo.strftime('%d/%m/%Y')} - Total demandas ({total_demandas}):\n"

    # Adicionar dados dos canais com gr√°ficos de barras
    for canal, quantidade in demanda_por_canal.items():
        barras = "‚ñà" * (quantidade // 1)  # Cada barra representa uma unidade
        mensagem += f"  {canal:<15}: {barras} ({quantidade})\n"

    mensagem += "\n"  # Linha em branco entre datas

# Adicionar mensagem final
mensagem += f"Total de demandas em aberto com prazos futuros: {demandas_total}\n\n"
mensagem += "Confer√™ncia finalizada ‚úî\n\n" if len(demandas_prazo_proximo) == 0 else "‚ùåConfer√™ncia em andamento. Verifique as demandas pendentes‚ùó\n\n"
mensagem += f"ùó¢ùòÇùòÉùó∂ùó±ùóºùóøùó∂ùóÆ ùó°ùó≤ùóºùóª\nùó¶ùóÆÃÉùóº ùó£ùóÆùòÇùóπùóº, {hoje.strftime('%d/%m/%Y')}\n"

# Combinar mensagens
resumo_analise += mensagem

# Passo 5: Gerar gr√°ficos

# Gr√°fico 1: Soma de demandas por data de entrada
demandas_por_data_entrada = df.groupby('Recebida').size()

plt.figure(figsize=(10, 6))
plt.bar(demandas_por_data_entrada.index.map(lambda x: x.strftime('%d/%m/%Y')), 
        demandas_por_data_entrada.values)
plt.title('Soma de Demandas por Data de Entrada')
plt.xlabel('Data de Entrada')
plt.ylabel('Total de Demandas')
plt.xticks(rotation=45)
plt.tight_layout()

# Adicionar r√≥tulos de dados
for i, v in enumerate(demandas_por_data_entrada):
    plt.text(i, v + 0.5, str(v), ha='center', va='bottom')

plt.show(block=False)
plt.pause(3)
plt.close()

# Gr√°fico 2: Demandas futuras ordenadas por prazo de resposta
demandas_futuras = df[df['Prazo'] >= hoje]
demandas_futuras_ordenadas = demandas_futuras.groupby('Prazo').size()

plt.figure(figsize=(10, 6))
plt.bar(demandas_futuras_ordenadas.index.map(lambda x: x.strftime('%d/%m/%Y')), demandas_futuras_ordenadas.values)
plt.title('Demandas Futuras Ordenadas por Prazo de Resposta')
plt.xlabel('Prazo de Resposta')
plt.ylabel('N√∫mero de Demandas')
plt.xticks(rotation=45)
plt.tight_layout()

# Adicionar r√≥tulos de dados
for i, v in enumerate(demandas_futuras_ordenadas):
    plt.text(i, v + 0.5, str(v), ha='center', va='bottom')

plt.show(block=False)
plt.pause(3)
plt.close()

# Passo 6: Descri√ß√£o da an√°lise
print("\nResumo da an√°lise:")
print(f"Total de demandas do dia atual ({hoje}): {len(demandas_dia)}")
print(f"Total de demandas com prazo de resposta at√© hoje: {len(demandas_prazo_proximo)}")

print(resumo_analise)

# Fun√ß√£o para enviar mensagem ao Slack
def enviar_para_slack(mensagem, canal):
    try:
        response = client.chat_postMessage(channel=canal, text=mensagem)
        print(f"Mensagem enviada para o Slack: {response['ts']}")
    except SlackApiError as e:
        print(f"Erro ao enviar mensagem para o Slack: {e.response['error']}")

# Pedido de confirma√ß√£o para o usu√°rio
confirmacao = input("\nDeseja enviar a confer√™ncia para o Slack? (s/n): ").strip().lower()

if confirmacao == 's':
    # Enviar resumo para o Slack
    enviar_para_slack(resumo_analise, canal_slack)
else:
    print("\nEnvio ao Slack cancelado.")

# Excluir o arquivo ap√≥s a leitura e o envio
exluir_arquivo = input ("\nDeseja exluir o arquivo da pasta download? (s/n): ").strip().lower()
if exluir_arquivo == 's':
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
            print(f"Arquivo {file_path} exclu√≠do com sucesso.")
        else:
            print(f"O arquivo {file_path} n√£o existe.")
    except Exception as e:
        print(f"Erro ao tentar excluir o arquivo: {e}")
else:
    print("\nArquivo mantido.")
