import re
from pykeepass import PyKeePass
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
import getpass
import pandas as pd

# Configurações do caminho
download_dir = r'C:\Users\u003985\Downloads'

# Acessando usuário e senha KeePass
frase_segura = getpass.getpass("Digite sua senha KeePass: ")
kp = PyKeePass(r'C:\Users\u003985\Documents\Consulta SCR\senhas.kdbx', password=frase_segura)

# Pergunta qual empresa acessar
empresa = input("Qual empresa deseja acessar? (1 para financeira, 2 para pagamentos): ")

# Configurações do navegador
chrome_options = Options()
chrome_options.add_experimental_option("prefs", {
    "download.default_directory": download_dir,
    "download.prompt_for_download": False,
    "download.directory_upgrade": True
})

# Acessando o site com webdriver
driver = webdriver.Chrome(options=chrome_options)
driver.get("https://www3.bcb.gov.br/rdr/consultaDemandaIFView.do?method=consultaDemandaNumeroInicial")

# Aguarda o carregamento completo da página inicial
WebDriverWait(driver, 10).until(lambda d: d.execute_script("return document.readyState") == "complete")

# Encontra as credenciais
if empresa == '1':
    entry = kp.find_entries(title='Neon Financeira Bacen', first=True)
else:
    entry = kp.find_entries(title='Nome_da_Entrada_Pagamentos', first=True)

if entry is None:
    print("Entrada não encontrada no KeePass.")
    driver.quit()
    exit()

username = entry.username
password = entry.password

# Insere o usuário e senha
driver.find_element(By.XPATH, '//*[@id="userNameInput"]').send_keys(username)
driver.find_element(By.XPATH, '//*[@id="passwordInput"]').send_keys(password)

# Clica no botão de login
driver.find_element(By.XPATH, '//*[@id="submitButton"]').click()

# Carrega a planilha com os Identificadores
df = pd.read_excel(r'C:\Users\u003985\Downloads\procedentes.xlsx')
df['Descrição'] = None

# Função para limpar caracteres inválidos
def limpar_texto(texto):
    if texto:
        texto = re.sub(r'[<>:"/\\|?*]', '', texto)  # Remove caracteres básicos
        texto = re.sub(r'[\x00-\x1F\x7F-\x9F]', '', texto)  # Remove outros caracteres de controle
        texto = texto.replace('→', '-')  # Substitui caracteres especiais
        return texto
    return texto

# Loop para processar cada demanda
for index, row in df.iterrows():
    identificador = row['Identificador']

    # Aguarda a página carregar e o elemento estar presente
    WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="idConsulta"]'))
    )

    # Tenta inserir o identificador
    driver.find_element(By.XPATH, '//*[@id="idConsulta"]').clear()
    driver.find_element(By.XPATH, '//*[@id="idConsulta"]').send_keys(identificador)
    driver.find_element(By.XPATH, '/html/body/div[10]/form/div/input').click()

    # Aguarda a descrição estar presente e visível
    descricao_element = WebDriverWait(driver, 10).until(
        EC.visibility_of_element_located((By.XPATH, '//*[@id="respondeDemandaForm"]/table/tbody/tr[24]/td[2]'))
    )

    # Captura todo o texto contido no <td>
    descricao = descricao_element.text
    descricao = limpar_texto(descricao)

    # Salva a descrição na coluna 'Descrição' do DataFrame
    df.at[index, 'Descrição'] = descricao

    if "IFAC" in descricao:
        # 1. Divide no máximo 1 vez e pega o segundo item (índice [1]), que é o texto DEPOIS do marcador.
        julgamento = descricao.split("IFAC", 1)[1]
        
        # 2. Agora 'julgamento' é um texto, então .strip() funciona corretamente.
        julgamento_limpo = julgamento.strip()
        
        # 3. Salva no DataFrame.
        df.at[index, 'Descrição'] = julgamento_limpo
    else:
        df.at[index, 'Descrição'] = ""

    # Retorna ao link inicial para processar a próxima demanda
    driver.get("https://www3.bcb.gov.br/rdr/consultaDemandaIFView.do?method=consultaDemandaNumeroInicial")
    WebDriverWait(driver, 10).until(lambda d: d.execute_script("return document.readyState") == "complete")

# Salvar a planilha como "Classificar atualizada"
df.to_excel(r'C:\Users\u003985\Downloads\IA_classificar_procedentes.xlsx', index=False)

print("Processo concluído e a nova planilha foi salva.")
driver.quit()
